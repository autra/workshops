## TP sur le partitionnement

<div class="slide-content">

  * Transformation d'une table référencée en table partitionnée
  * Fonctions d'information sur le partitionnement
  * Nouvelle commande `\dP` pour les partitions

</div>

<div class="notes">

### Clés étrangères vers une table partitionnée

Créer les deux tables `job` et `job_detail` avec une contrainte de clé étrangère.

```sql
CREATE TABLE job (
   id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   job_start TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
   job_end TIMESTAMP WITH TIME ZONE,
   job_name VARCHAR(50) NOT NULL
);
CREATE INDEX ON job(job_start);

CREATE TABLE job_detail (
   jobid INT REFERENCES job(id) ON DELETE CASCADE NOT NULL,
   log_date TIMESTAMP WITH TIME ZONE NOT NULL,
   log_message TEXT NOT NULL
);

-- Quelques données dans les tables
INSERT INTO job (job_end, job_name) VALUES 
   (now() + INTERVAL '1 hour', 'Daily routine');
INSERT INTO job_detail VALUES 
   (currval('job_id_seq'), now(), 'Purge is started');
INSERT INTO job_detail VALUES 
   (currval('job_id_seq'), now() + INTERVAL '1 hour', 'Purge is completed');

INSERT INTO job (job_end, job_name) VALUES 
   (now() + INTERVAL '2 hour', 'Other daily routine');
INSERT INTO job_detail VALUES 
   (currval('job_id_seq'), now(), 'Routine is started');
INSERT INTO job_detail VALUES 
   (currval('job_id_seq'), now() + INTERVAL '2 hour', 'Routine is completed');
```

Dans un contexte de croissance, le nombre de travaux (_jobs_) augmente considérablement
et la purge de la table devient périlleuse au long terme. La transformation de 
cette table en table partionnée se revèle nécessaire.

Créer une table `job_part` ayant la même structure que la table `job` en ajoutant
le champ `job_start` dans la contrainte de clé primaire pour satisfaire les
prérequis de la clé de partionnement.

```sql
CREATE TABLE job_part
   (LIKE job INCLUDING DEFAULTS INCLUDING IDENTITY )
   PARTITION BY RANGE (job_start);
```

La prochaine étape consiste à rattacher la table `job` en tant que partition
par défaut de la future table partitionnée. Pour cela, il peut être judicieux de 
jouer les instructions dans une seule transaction et de prêter garde au respect
de la contrainte étrangère sur la table `job_detail`.

```sql
START TRANSACTION;

-- Redéfinition de la contrainte de clé primaire sur la table partitionnée
ALTER TABLE job_detail DROP CONSTRAINT IF EXISTS job_detail_jobid_fkey;
ALTER TABLE job DROP CONSTRAINT IF EXISTS job_pkey;

-- Ajout de la table job en tant que partition
ALTER TABLE job_part ATTACH PARTITION job DEFAULT;
ALTER TABLE job_PART ADD PRIMARY KEY (id, job_start);
CREATE INDEX ON job_part(job_start);

-- Récupération de la dernière valeur de la séquence de la précédente table
SELECT setval(pg_get_serial_sequence('job_part', 'id'),
       nextval(pg_get_serial_sequence('job', 'id')), true);

-- Suppression de l'ancienne séquence et de sa relation avec la partition job
ALTER TABLE job ALTER id DROP IDENTITY, ALTER job_start DROP DEFAULT;

-- Réactivation des contraintes de clés étrangères
-- Puisque la colonne job_start fait à présent partie de la PRIMARY KEY, il est
-- nécessaire d'ajouter cette colonne dans la table job_detail et de l'alimenter
ALTER TABLE job_detail ADD job_start TIMESTAMP WITH TIME ZONE;
UPDATE job_detail SET job_start = j.job_start
  FROM job j WHERE (j.id = jobid) ; 

ALTER TABLE job_detail ADD FOREIGN KEY (jobid, job_start) 
   REFERENCES job(id, job_start) ON DELETE CASCADE;

COMMIT;
```

Une étape optionnelle serait de renommer les relations pour être totalement
transparent avec le fonctionnement applicatif.

```sql
START TRANSACTION;

-- Renommage des relations pour maintenir la logique métier
ALTER TABLE job RENAME TO job_default;
ALTER TABLE job_part RENAME TO job;
ALTER SEQUENCE job_part_id_seq RENAME TO job_id_seq;

COMMIT;
```

À partir de cette étape, la table `job` est partitionnée mais toutes les lignes
passées et à venir sont stockées dans la partition `job_default`. Il est possible
de déplacer les lignes d'une partition vers une nouvelle, bien qu'il soit recommandé
de maîtriser les requêtes en provenance des utilisateurs car une série de verrous
seront posés entre les tables.

```sql
CREATE OR REPLACE PROCEDURE add_daily_partition(timestamp with time zone)
   LANGUAGE plpgsql AS $$
   DECLARE
      daily_interval INTERVAL := INTERVAL '1 day';
      tablename   VARCHAR(50) := format('job_%s', TO_CHAR($1, 'YYYYMMDD'));
      from_expr   VARCHAR(50) := date_trunc('day', $1);
      to_expr     VARCHAR(50) := date_trunc('day', $1 + daily_interval);

   BEGIN
      EXECUTE format(
         'CREATE TABLE IF NOT EXISTS %s (LIKE job_default INCLUDING CONSTRAINTS);', 
         tablename
      );      
      EXECUTE format(
         'INSERT INTO %s SELECT * FROM job_default WHERE job_start BETWEEN ''%s'' AND ''%s'';',
         tablename, from_expr, to_expr
      );      
      EXECUTE format(
         'DELETE FROM job_default WHERE job_start BETWEEN ''%s'' AND ''%s'';',
         from_expr, to_expr
      );
      EXECUTE format(
         'ALTER TABLE job ATTACH PARTITION %s FOR VALUES FROM (''%s'') TO (''%s'');',
         tablename, from_expr, to_expr
      );
   END;
$$; 

START TRANSACTION;
LOCK TABLE job;
LOCK TABLE job_detail;

-- Retrait temporaire de la clé étrangère pour réduire les risques 
-- de suppression en cascade
ALTER TABLE job_detail DROP CONSTRAINT IF EXISTS job_detail_jobid_job_start_fkey;
CALL add_daily_partition (now());
ALTER TABLE job_detail ADD FOREIGN KEY (jobid, job_start) 
   REFERENCES job(id, job_start) ON DELETE CASCADE;

COMMIT;
```

### Fonctions d'information sur le partitionnement

`pg_partition_root` renvoie la partition mère d’une partition.

```sql
$ SELECT pg_partition_root('job_default');

 pg_partition_root 
-------------------
 job
(1 row)
```

`pg_partition_ancestors` renvoie la partition mère ainsi que la partition concernée.

```sql
$ SELECT pg_partition_ancestors('job_default');

 pg_partition_ancestors 
------------------------
 job_default
 job
(2 rows)
```

`pg_partition_tree` renvoie tout l’arbre de la partition sous forme de tuples.

```sql
$ SELECT * from pg_partition_tree('job');

    relid     | parentrelid | isleaf | level 
--------------+-------------+--------+-------
 job          |             | f      |     0
 job_default  | job         | t      |     1
 job_20200124 | job         | t      |     1
(3 rows)
```

###  Affichage des tables partitionnées seules

La commande psql `\dP` permet à présent d'afficher les tables partitionnées,
contrairement à la commande `\d` qui affiche toutes les relations de la base.

```sql
$ \d
                   List of relations
 Schema |     Name     |       Type        |  Owner
--------+------------+--------------------+--------------
 public | job          | partitioned table | postgres
 public | job_20200124 | table             | postgres
 public | job_default  | table             | postgres
 public | job_detail   | table             | postgres
 public | job_id_seq   | sequence          | postgres
(5 rows)

$ \dP
                  List of partitioned relations
 Schema |       Name        |  Owner   |       Type        | Table 
--------+-------------------+----------+-------------------+-------
 public | job               | postgres | partitioned table | 
 public | job_job_start_idx | postgres | partitioned index | job
 public | job_part_pkey     | postgres | partitioned index | job
(3 rows)
```

</div>

----
